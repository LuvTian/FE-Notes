网页视频嵌入代码：<object type="application/x-shockwave-flash" data="88.gif" width="200" height="200">
            <param name="movie" value="88.gif">
        </object>


<p>表格中，最重要的两个元素，行与列<br />
    
    一张表--bable<br />
    table有一或多行--row---tr<br />

    一行又可能分一列或多列---colunm
    </p>

    <table border="1">
        <tr><td>aa</td><td>aa</td><td>aa</td></tr>
        <tr><td>姓名</td><td>年龄</td><td>身高</td></tr>
        <tr><td>刘备</td><td>28</td><td>175</td></tr>
        <tr><td>关羽</td><td>25</td><td>190</td></tr>
        <tr><td>张飞</td><td>23</td><td>180</td></tr>
    </table>
    
    <p>
    这是一个最基本的表格，
    更重要的还有：列的合并，行的合并，列与行都合并这种情况。
    </p>
    
    <p>如何通过css控制表格的边框，样式
    </p>
/*
table {
    border:solid 1px blue;
}
td {
    border:solid 1px red;
}

table {
    border-collapse:collapse;
    border-spacing:5px;
    empty-cells:hide;
}*/

table {
    border:solid 1px blue;
}   
td {
    border:solid 1px red;
}

table {
    border-sapcing:5px;
    empty-cells:hide;/*清除空的单元格*/
}
</style>
</head>
    <body>
        <p>合并列，合并行的小技巧，<br />
        先把合并后，要消失的TD删除掉<br />
        数一数留下的TD要跨几行，或几列<br />
        再通过rowspan="N",或者colspan="N"
        </p>
    <table>
        <tr><td colspan="3">年龄</td></tr>
        <tr><td>11</td><td>男</td><td rowspan="3">2</td></tr>
        <tr><td>11</td><td>男</td></tr>
        <tr><td>22</td><td>女</td></tr>
    </table>

    <p>
        <ul>
            <li>表格的达标要求</li>
            <li>做一个3行3列基本表格</li>
            <li>在上述表格基础上，完成殊合并</li>
            <li>要能用css来控制表格的边框，以及边框的整合效果</li>
        </ul>
    </p>




<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN">
<head>
<title>学习背景</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="" />
<meta name="keywords" content="" />

<style type="text/css">

#header{
    width:800px;
    height:2000px;
    border:solid blue;
    background:gray url(88.gif) no-repeat fixed;
}

#jian{
    width:30px;
    height:25px;
    background:url(126.jpg) 0 -50px;
    border:solid 1px blue;
}

</style>
</head>
    <body>
        <div id="header"></div>
        <h2>通过背景的postion属性来实现多个共用一张背景图的效果</h2>
        <div id="jian"></div>
    </body>
</html>

转义字符：

<head>
    <body>
        <div>
           <h2>符号实体就是外号</h2>
           <h2>符号实体的表示方式:&xxx;</h2>
           3 &gt; 2

           我就是&amp;符本身

            <ul>
                <li>常见的符号实体</li>
                <li>&gt; --- &amp;gt;</li>
                <li>&lt; --- &amp;lt;</li>
                <li>空格 --- &amp;nbsp;</li>
                <li>&copy; --- &amp;copy;</li>
                <li>&reg; --- &amp;reg;</li>

            </ul>

       </div>

bug调试：
1、doctype文档声明
解决：进行xhtml 正确声明，如strict声明
2、浏览器的初始值不同带来的。
解决进行css初始化
3、自身代码不规范带来的bug
解决：多看
4、浏览器的bug带来的。
4.1 IE6，有双倍margin bug
是指浮动方向上的margin值会加倍
例如：某元素float:left,margin-left的值是10px，页面上会解析为20px,
同时，float-right,margin-right也会加倍
解决方案：给漂浮元素的  _dispay:inline;
4.2:像素bug
解决：规范float
4.3:IE关于a标签的4个伪类的兼容bug
答：对于IE，如果以a：link方式声明了标签的样式
可能会引来visited伪类的解析异常
解决：去掉a:link,a来代替

IE的 BUG
img,object
selexct,input,textarea
这5处元素，和其他内联元素相比，
即使是标签，也已经有一定的显示效果
或者是标签本身体现的内容，是一个外部资源，
例  img--> src,object->wmv/flash等

对于这一类元素，w3c给出的名称是replaced element ,置换元素

置换元素，可以设宽和高，以及竖直、水平方向的margin,padding,
和块一样

但是，他们又不换行，体现内联的特性
并且，结束后，下方会有留白，也是体现内联的特性



框架集：

doctype声明：模式为：frameset

做框架时不要body，直接用
<frameset rows(行)/cols(列)="...px,...px">
	<frame scr="#" name="  "></frame>
</frameset>

key---value
发送的变量名-----变量值

form----method的两种方法比较
GET与POST
GET提交表单的值直接体现在浏览器上
POST提交直接提交到action规则的url,url不变

GET提交直接把数据体现在地址栏上，不够安全
而POST不改变地址栏，直接发送数据，因为这样注册的场合，适合POST提交

action 代表表单要提交到的页面
method 代表表单提交的方法（即表单数据如何发送）

例：<form method="POST" action="http//www.baidu.com">

	<input***></input****>
    </form>

常用类型：type=""
text:文本  password:密码  radio:单选  checkbox:多选  file:上传文件
textarea:文本域  hidden:隐藏的信息  submit:提交、注册、登录  reset:重填
image:图片按钮

如何给表单项加默认值：
答：对于text文本框，password密码框、加value="***"

对于textarea大块文本域，默认值直接写在textarea标签之间,例：<textarea>这里填写默认值</textarea>
textarea标签不能换行，否则空格会成为默认值

对于 单选radio 和 多选的checkbox  checked="checked"就能默认选中

对于select下拉框
Option选项加selected="selected"就能默认选中

对于文件类型是不能设置默认值的


javascript---------------------------------------------------------------

Js如何操作的DOM？
浏览器有html源码渲染的功能，把html源码在内存里形成一个DOM对象，也有一个javascript的解释器/执行器/引擎
我们在html里写一个js代码，js代码被引擎所执行，而执行的结果就是对DOM的操作，
而对DOM操作的结果，就是我们看到的特效，比如：图片漂浮，文字变色、、、

1：javascript语言本身的语法
2：DOM对象
3：BOM模型browser，浏览器模型

基本流程：写指令给浏览器的javascript引擎，再由javascript引擎去修改DOM模型

变量----------------------------------------------------------

变量的赋值，b=a，可以把a的值读出来，存储到b的相应空间。
这样的话，a,b是相互独立的，修改时不影响对方。

这种情况叫“传递赋值”

还有另外一种情况，就是"引用传值(赋值)"

在javascript语言里，不必像PHP那样用“&”符号来声明引用赋值。

javascript里，数组，对象，函数，这三者默认都是引用赋值的。

Js变量名称的要求------------------------------------------------

1：变量名只能用  字母、下划线、数字、$，这4种组成。
但是，不能用数字做开头

换个说法：首字符可以是字母、下划线、$，后面的字符可以是以上4种组合。

alert:就是弹一个窗口出来

变量名区别大小写
例：age 和 Age 不是同一个变量

变量的命名要有意义，不要用a.b.c......不易理解的字符。

var age = 22;
age= 22;//这是一种不规范的写法，与加var的区别很大，不要这样写。

变量也允许先声明 ，但是不赋值
例:var a,b;

在html代码中，如何引入javascript
（和css的引入对比学习）

1：
你可以用<script type="text/javascript">

    code…………

</script>

2：可以把js代码拿到一个专门的.js文件里面。
然后引用此文件。

<script type="text/javascript" src=""></script>

注意：外部的.js文件里面直接写js代码，
不要在开头和结尾加<script></script>标签

3：注意一种错误的写法：

<script type="text/javascript" src="1.js">
    var _name = '张三';
    alert(_name);
</script>

4：请注意：如果用2种方式混合，引入多个script文件。
运行效果相当于按顺序，把多个script的代码合起来，按顺序运行。

5：<script>标签</script>可以写在页面的哪个位置？

答：页面head和body都可以写。
而且，有的时候会因为写在head区出现一些意外。

比如在head的script代码试图去访问body中的DOM对象，
就会提示找不到。

javascript里面如何写注释：

1：多行注释

/*
XXXXXX
XXXX
*/

2：单行注释

//后面写注释

运算符：
算术运算符：+，-，*，/，%（%求余）
9%2，===余1

注意点：在js里，求余的时候是可以对浮点数求余的

和PHP不一样，PHP求余的结果是整型。
可以这样：30.5%7=2.5，30%4.3=4.200000000000001
-30.5%7=-2.5

    //请注意，编程语言，中止js中，都要求除数不能为0
    //如下例;4.8除以0得到Infinity
    document.write(num + '除以0' + '得到' + num/0 + "<br />");

条件运算符：>,<,==,!=,>=,<=,===,!==

>,<,>=,<=
注意：条件运算符的运算结果，为布尔类型

===代表全等于，就是不仅值相等，而且类型也相等

比如1==true，但是 1!=true

注意：+号运算时，如果有一个操作数是字符串，那么最终得到的结果就是字符串

赋值运算符：
赋值运算就是把 = 右侧的直接值或或表达式的值赋给左侧的变量

例：age = 22;
      age = 2012-birth;
      age = age + 1,------>可以简写为age += 1;

那就是说：

变量名 = 变量名 +，-，*，/，%值-------->变量名+，-，*，/，% = 值；

例：a = a + 1;---->  a += 1;

a = a - 2 -----> a -= 2;

a = a * 3------>a *= 3;

a = a / 4------>a /= 4;

a = a % 5----->a %= 5;

1:理解变量名，变量存储地址，变量值的概念
答：变量名---代表-->变量的内存地址。
alert(变量名)--->根据变量名-->找到地址-->从地地址读出值

2：传递赋值与引用赋值的区别？
答：如果是传递赋值   a = b,
给a分配地址，读出b的值，把b值存到a的内存地址上。
这样，修改a, b互不影响对方。

如果是引用赋值，a = b；
其实是声明一个变量a，并且变量a的地址也指向b的内存地址。
所以，修改a,b会同样影响对方，
但是删除a,b不会影响对方。

（信用卡有主卡，有副卡，主卡刷卡，副卡也能看到影响；副卡刷也同理）
但是如果主卡，或者副卡有一张丢了，另一张还能正常使用。

3：js中哪些数据类型是引用赋值？
答：在php中，可以明确的用$a = &$b，在地址前加&符业声明引用赋值。
但是在js中，数组，对象，函数是默认引用赋值，其他是传递赋值。

4：回答js中的5种数据基本类型与复合类型
答：Number,String,Boolean,null,undefined
数组，对象，函数

5：html引入js的方法
答：在页面中引入
<script type="text/javascript">
</script>

2：把js脚本单独写在一个.js结尾的文件中
<script type="text/javascript" src="XXX.js"></script>

6：js的单行，多行注释的写法

// 这是单行注释

/*
这是多行注释
*/

7:变量名的命名规范
答：由数字，字母，下划线，$符组成，但是首字符不能是数字。
同时注意：不能和关键字冲突。
例：    if var = if


逻辑运算符：
或者：||
并且：&&


或者：  房子 || 有车
房子和车满足一个就为真，就成立，当然两个也成立、
（如果第一个条件满足，后面的表达式往往不会进行，这个叫做短路运算）

并且：  有房 && 有车
当判断有房为真时，并不能确定"有房且有车"成立，还得继续判断有车成立才行。
但是，如果没有房呢？没必要再判断是否有车了，因为这个"有房且有车"必为假
（对于第 一个条件不成立的时候，后面的表达式不会进行）

真 且 真：真
真 且 假：假
假 且 假：假

真 或 真：真
真 或 假：真
假 或 假：假

Js里逻辑运算的特殊性，返回的不是布尔值，而是表达式判断出结果时的子表达式的值


自增自减运算符
++,--
有的时候，我们需要这种效果。
先用到a的值，用了之后，顺手再加/减1
或者先加/减1，然后再用到a的值。

++a，的意义：先把变量a加1，使用加1后的值
++a/--a:先把a的值加/减1，然后再返回加减后的值
相当于：a = a + 1,return a;

a++/a--:先返回a的值供使用，再把值 加减1；
retrun a;a = a + 1;

a = 10;
b = a++;
a++先把内存中a的值读出来，10

比如：你去商店买东西，有一块黑板，上面记录已经来过的的客人数量，你刚看到时，看见写的10，
你记录了这个10，但你买完东西走之后，黑板上的数更新11.

三元运算符
表达式1 ? 表达式2 : 表达式3
理解：
表达式1如果为真，则返回表达式2的值，
表达式1如果为假，则返回表达式3的值，

如果没有3元运算符，我们可以用if/else来代替


控制结构 之  单路分支
if(表达式) {
       代码段，//可以是一句，也可以是多句
}

表达式为真，则代码段执行，为假则代码段不执行
而一个表达式被if判断时，只有2种可能------真/假,true/false
代码段：要么整体执行，要么整体不执行

if(表达式){
      代码段1;
}else{
      代码段2;
}
如果表达式为真，则执行代码段1;
如果为表达式为假，则执行代码段2;

else是在if(表达式)的判断基础是进行的，因此，eles(表达式)是不允许的

代码段1，和代码段2，必有一段被执行

if(表达式1){
      代码段1;
}else if(表达式2){
      代码段2;
}else if(表达式N){
      代码段N;
}else {

}//最后一个else不写也行，

从前到后，逐个判断,
如果表达式1为真，则执行代码段1，同时跳出本分支判断--即后面的分支不再进行

题目：
给定一个数[1,2,3,4,5,6,7]之间，来判断
分别显示：今天是 星期一，二，三，四，五，六，七
用 if/else if/  完成


switch分支语句
switch(表达式){
      case 值 1:
      代码段 1;
      break;

      case 值 2:
      代码段 2;
      break;

      case 值 N:
      代码段 N;
      break;

      default:
      代码段 default;
}

注意：switch中的case代码段结束后，一定要加break
如果不加，则满足条件的case后面的所有case的代码段都将执行

switch 与if/else if 相比，各有什么特点呢？

switch 判断的是 表达式 == (case 后面的) N

就是说：碰到需要比较范围的，用switch不适合，应该用 if/else if
例如： age >= 0 && age <= 3, age > 4 && age <= 10,age <10 && age <= 16

既然switch比较的是值，那么比较什么值比较合适呢？
比较 整型，字符串 的场合更适合

循环结构之 while 循环

while  当 XXX 的时候

while(表达式) {
      代码段 0
}
语句1：



if(表达式) {
      代码段 0
}
语句1：

var i = 1;
while(i <= 100) {
    ++i;  //i += 1;
    i++;  //i += 1;
    document.write(i + "<br />");
}

两种情况可打印多少？

思考：
如果有单独的2行语句

i++;
++i;
他的作用有何不同？
这时没有任何不同，都是起到 i += 1效果。

逻辑运算
逻辑运算  &&, ||.
在PHP中，逻辑运算返回的是布尔值，true/false
而在js中，逻辑运算稍有特殊，
返回的是能确定整体表达式的值的第一个表达的值。

//这些东西被用来做逻辑判断的时候当成假：
false,0,' ',null,undefined,
这些是假，除外当真


var res = 3 || null;

alert(res);//3

var res = 0 || ralse;
alert(res); //false;

var res = true && 9;
alert(res);//9

var res = false && true;
alert(res); //false

3元运算：
表达式1 ? 表达式2 : 表达式3;
表达式1为真，则执行表达式2，否则执行表达式3

if(表达式1){
    表达式2;
}else {
    表达式3;
}

分支结构

if(表达式){
    语句块;
}
语句要么不执行，要么执行一次

if(表达式){
    语句块1;
}else {
    语句块2;
}

语句块1和语句块2必有一段被执行

if(表达式1){
}else if(表达式2){
}...... else {
}

while循环
while(表达式){
    语句块;
}
语句块有可能执行几次
0次，
N次，
次无限循环



do {
    代码段;
}while(表达式);

do:做，执行，完成
while:当 XXX 时候

while (表达式){
    代码段    //while 循环中的代码段，可能执行 0 次，也可能N次，也可能是无限循环
}

do/whille 先执行代码段，再while判断表达式
也就是说，如果判断为假，则循环退出，如果判断为真则继续 do{}
换句放大说，do{}这一段语句至少执行1次。

例：有的饭馆，先交费，再上菜，
如果你没钱，不会给你做菜，直接走人。

有的饭馆，先上再吃，然后再结账
即使你的钱不够，但是---菜已经吃了

循环的退出：
break:破坏
continue:继续

break 在循环体内部，跳出本循环或者说：终止当前的循环过程

cuntinue 是跳过本次循环步骤.

现实例子：一个队伍100个人，找脚底板有一颗痣的人，找到29位时，找到了。
那么此时后面的人不用再找了。   break

如果我们要枪毙100人，碰到第29个人，他是个好人，被冤枉的，因此跳过此人

for 循环

//for循环在大部分语言中，都是非常重要的一个语言结构

例：
有一个人出差，公司给你10050元钱，出差每天花300，每天去做业务。
想一想这个人什么时候回来？
----当他的钱已经不够一天的差旅费时，回来 ------这次出差结束了。

1.给你10050.   -----给且只给一只，在循环的刚开始就给
2.先判断一下够不够一天的差旅费，如果不够，出差结束。
3.每天花300.
4.做业务

for(表达式1,表达式2,表达式3){
    语句体
}

表达式1---->先给10050.对于for来说，表达式1先执行，并且只执行一次。
表达式2---->判断是否满足某个条件。
语句体-----> 做业务
表达式3----->每天花钱

for循环3个表达式可以写或不写么？
答：for循环的3个表达式可以写0 - 3个，
也就是说，3个表达式都可以省略
如果全部省略相当于while(true)的效果

for循环嵌套时，如何在内层结束外层的循环

可以给外层for循环加一个标签：
例：
bajji:
for (var g = 1;g <= 18 ;g++ )
{
    for (var m = 1;m <= 33 ;m++ )
    {
        var c = 100 - g - m;
        if ((g+m+c) == 100 && (5*g + 3*m + c/3) == 100)
        {
            document.write("公鸡" + g +"母鸡" + m + "小鸡" + c + "<br />");
            break baiji;
        }
    }
}

函数：
程序中的函数是指一段封闭的代码段，能够完成选定功能

函数的用法：
函数的用法分为声明和调用
被调用的函数必须在页面内有声明过程

函数的声明方法
function 函数名([arg1][,arg2][,arg3][..argN])(
	代码段运行,
	[return 返回值]
)
注：可以有0>N个参数，但只有一个返回值

函数的调用方法
函数名:([arg1][,arg2][,arg3][..argN]);

函数的返回值
函数可以有0个或1个返回值，没有 其他情况

返回值给谁了？
谁调用就给谁了

函数的执行权与执行权的交回
Js代码由js引擎解释执行，有几个js引擎同时工作呢？
答：只有一个，单线程运行
所以：指令只能一条一条来运行.
当函数被调用时，js解释引擎进入到函数内部去工作
即执行权交给了函数.

函数在两种情况下，交回执行权：
1：碰到return，执行权交回。
2：如果没有return，函数的语句运行完毕后，执行权交回。

一个函数可以有几个return单词？
答：0到多个

这个函数的return可以执行几次？
答：只能执行0次或1次

js中函数的特殊性--和PHP比较

在PHP中，函数就是语法上的结构体，不是一个变量，不能被赋值
但是在js中，函数也是一种变量。

变量名就是函数名

声明函数
function 函数名(参数){
      函数体
}
-------->声明了一个叫做"函数名"的变量，并且变量的内容是
"(参数){
      函数体
}"

parseInt:把字符串的___前缀___部分的数字分析成整型数字

如果首字符不是数字，分析出“非数字”----NaN

parseInt,如果碰到前缀是有小数点的情况，直接舍弃小数点后面的部分并保留整数


parseFloat:把字符串的前缀部分的数字分析成浮点型


NaN---->一个特殊变量,代表非数字.
isNaN() 用来判断某个变量为'非数字';正无穷大，负无穷大.N

提示：
在数学里    1/0 ----------->没有意义.或者"无穷大"
-1/0 ----->负无穷大

eval() :执行一段js代码.
比如两台计算机做通信,a--->b,有可能发xml,json数据等等
也有可能直接发送js代码.
eval'alert("快点回话")'


数组：
数组：就是一组变量

数组的创建：
var arr = [];
var arr = new Array();

var arr = ['a','b','c','d'];
var arr = new Aarray('a','b','c','d');

创建一定长度但无内容的数组
var arr = new Array(10);

数组每个单元都有一个唯一的“下标/索引”，从0编号，编到length - 1;

数组单元值的读取,
可以凭数组的索引值来确定
即arr[index]这个形式

数组的遍历
for循环配合 数组长度 + 索引的知识
例：
    //要求：把arr的每一个单元打印在页面上
   var arr = ['a','b','c','d'];

    for(var i = 0, len = arr.length;i < len; i++){
        document.write(arr[i] + "<br />");
    }

数组length的属性的变化

设某数组 length == N
如果修改length，且length < N，则数组被截断，后面的丢失了
如果length > N ,则数组自动补到length个，新加的单元以undefined来填充


函数：

函数的概念：
1：从数学角度看，体现变量的运算关系
比如：正方形面积与边长的关系。
f(a):面积 = a^2
f(a) = a^2

function area(a){
	return a^2;
}

2:从程序角度看，函数封装特定功能的代码，供调用

function tea(){
	document.write('a');
	document.write('b');
	document.write('c');
	document.write('d');
}

t();
这时可以把函数理解为一个“语句包”，
调用函数，其实就是一次性的把“语句包”内的内容都执行.

3:函数想调用函数t();
必须声明函数t

函数分“声明”和“调用”两个重要过程

4:函数的声明：
function functionName([arg1],[arg2],[arg3],...[argN]){ //参数可以有0个到多个
	//函数体
	//…………

	return [结果]; //函数可以不return，也可以return 1个值
}

5:
函数的执行权与交回
函数被调用的时候，例：t();
此时，js解释引擎进到函数内部，去执行函数体。

碰到2种情况的时候，执行权交回
a：碰到retrun语句;
b：执行到函数最后一个语句

6：函数的作用域：

如果有多层的函数嵌套。
那么内层函数如何寻找变量？
从内向外寻找，心最近找到的为准。

外层能否往里找到内层函数定义的变量？ 答：不能。

7：如果在内层函数，定义变量时，不用var ,而是 a = 3;
此时，a在全局发挥作用。
造成“全局污染”


==========数组===========
1:数组的概念
数组就是一组有序号的变量的集合

2：数组的创建方式：
创建空数组：
var arr = [];
var arr = new Array();
创建非空数组
var arr = ['a','b','c'];
var arr = new Array('a','b','c');

如何创建一个有长度，但每个单元都没内容的数组？
var arr = new Array(10);
//new Array(arg).如果参数是整型， >=0,则把这个参数理解为数组长度

3：数组索引特点
数组的索引从0开始，
数组的单元个数，就是数组长度，假设为N
索引最大值 是N-1；

4：数组单元值的读取：
利用索引来读，arr[index],例:arr[4];

5：如何遍历数组，for,索引与长度的关系，单元值的读取.
思路：从0遍历的N-1，利用遍历中的值，做索引来读取每个单元的值，
for (i = 0,len = arr.length;i < len; i++){
	// arr[i]
}

//正序&倒序同时打印数组

for(i = 0,len = arr.length , j = len - 1;i < len ;i++,j--){
	document,write(arr[i] +'--------' + arr[j]);
}


对象：
数组是一组标号“有序”的变量集合

创建一个对象
和创建数组的"[]"不一样，创建对象用{}
和创建数组直接放置不一样，创建对象时值前面还要加“属性”
创建语法：{属性1:值1,属性2:值2}

对象单元值的引用
obj.属性
或者obj['属性'];

对象如何遍历？？

for (per in obj){
   xxxx
}

注意：在for in结构中，利用循环得到的属性，取值时，
不能用obj属性的方式

对象单元值的删除：
delete obj属性


在js中，函数本身就是变量
而数组和对象存储的就是“变量”
对象的某个属性的值 ----- 有没有是一个函数呢？

答：可以，对象的某个属性对应的值，可以是函数
如果是函数时呢，这个属性往往也叫‘方法’.

如果对象的某个“方法”需要调用自身的某个属性值
可以在函数中用一个关键词来代替‘自己’这个对象！
this--->代表对象自己
/*
结合现实中的例子：
一张纸，前面写前：请在以下空格内，签上自己的名字，
那么张三来签时，就签‘张三’
李四来签时，就签‘李四’，谁签的时候，就签‘谁自己’的名字
*/


js的内置对象

在js中，所有的变量，都可以被js引擎包装成“对象”来处理
比如：str = 'abcd'; //字符串本身是没有length属性的
但是如果你去调用str.length,
在调用的前一瞬间，js执行引擎，会把他包装一下，当成一个对象来处理，并且给这个赋了一些属性和方法


对于字符串，布尔型，数值类型，数组，null，以及Math
这些变量，虽然没有属性
但是有调用的前一瞬间，js会为他们包装一些属性和方法


还有一些系统内置对象，是通过 new 得来的，当然也拥有属性和方法
比如 日期/时间对象
用的时候，必先通过new来得到一个对象
然后再调用对象的方法和属性

特效就是DOM操作的具体应用。
DOM操作就是用js来写html代码。


节点/元素/标签

想操作DOM对象？
对DOM的操作：
修改 ---> 先找到这个节点
删除 ---> 先找到这个节点
增添 ---> 先造出一个节点，然后插入，插入到哪儿？ --> 找节点来定位

节点的'查找'最重要！！

1:document.getElementById:根据id来查找节点,返回的是“节点”本身

2:doucment.getElementsByTagName:通过标签来查找节点，返回“数组”

3:document.getElementsByName,通过name属性来查找节点

注意：是期浏览器中认为name只出现表单中，
因此,document.getElementsByName 只对表单中的元素发挥作用
后来，部分浏览器把name 属性扩展到一般的元素如div.
但是 IE 没变，还是只能对表单使用byName.
因此，出于兼容性：我们只应对表单使用byName.


所有的元素都能够用 style--css来控制
所有的元素都有一个属性或者叫子对象---------style对象


DOM中查找节点的思路
由大到小来寻找，个别情况也可能由子不对劲父.

由大到小：通过下面3个方法来进行大的定位
1:document.getElementById:根据id来查找节点,返回的是“节点”本身
2:doucment.getElementsByTagName:通过标签来查找节点，返回“数组”
3:document.getElementsByName,通过name属性来查找节点

如果还没有查到想要的结果，还可以根据前面已经找到的节点再次定位来，
继续查找


1:查找子元素
childNods / children [index]

2:先查找父元素
node.parentNode ------>来获取父元素

2.5:firstChild,lastChild,

3:nextSibling,previousSibling 兄弟元素
这4个属性受“空白”文本的影响，建议不用

4:如果查到的某个元素仍然非常大，这个时候
我们还可以利用getElementsByTagName来进一步筛选
注意：对于元素对象和document  对象相比 
元素对象只能利用第___2___个函数，其他两个不可以使用
1:getElementById
2:getElementsByTagName
3:getElementsByName



0:js对象的概念
数组是有序的“键值对”，下标/索引 ---> 值。
对象是一组无序的键值对

创建数组可以用[v1,v2,v3]，不必指定索引
因为数组的索引默认从0而且逐一递增，因此不必指定，系统自动分配
创建对象{age:22,height:175};

引用数组的单元：假设数组变量arr,arr[index],索引值的范围是0--length-1;
引用对象的单元：假设对象变量obj,obj[property],obj.property

遍历数组：for(i=0;i<arr.length-1;i++){}
var obj = {name:zhang,height:175,age:22};
for(var per in obj){

}

把'name'赋给per,此时per等于'name',[做相应的操作]
把'height'赋给per,此时per等于'height',[做相应的操作]
把'age'赋给per,此时per等于'age',[做相应的操作]

1:js内置对象的方法
在js里，除undefined外，其他一切数据都被js当成对象来处理

以String为例：
var str = 'hello'; //str只是一具字符串，属性/方法那些东西是对象才有的特性.

但是是，如果引用str的属性或者调用方法时，
在调用的前一瞬间，js引擎会把字符串包装成一个“对象”。
还包装了一些属性：length,indexOf(),substr()等
这个过程是系统完成的，我们不必关心

我们要关心的：到底包装了哪些属性和方法

同理：
var arr = ['a','b','c'];
var arr = new Array('a','b','c');

内置对象：
日期时间对象类：Date()
var today = new Date();
// Date()函数是所有日期时间对象的一具“抽象模板”，而today是通过Date()造出来的一个具体对象

还有一个对象，是js已经创建完毕的，不必再new来得到。
Math 数学对象
Math.random();
.....
Math.ceil();

2:

DOM操作---
节点增加
节点删除
节点修改

以上3点都得先“节点查找”

目标：能查找页面上任意一个节点
节点查找的思路：
页面最大的是document--文档对象

我们的思路：
一般是从大到小，先定位 
定位后再根据父子/兄弟关系再详细定位

从document的角度出发，我们可以用以下3种方法先寻找：
document.getElementById();//返回值是“节点”
document.getElementsByTagName(); // 返回值是“数组”
document.getElementsByName(); //返回的是“数组”

注意：ByName只能在表单中，才能保证兼容;


通过以上3种方式定位后，如果找到的节点已经比较小/具体，
可以以这个节点为坐标，
通过children,parentNode,nextSibling,previovsSibling来定位子元素，父元素，下一个兄弟节点，上一个兄弟节点

如果通过以上3种方式定位，找到的节点依然非常大，内部的子节点依然非常多，
我们还可以继续利用getElementsByTagName()继续寻找
例：nodep.getElementsByTagName('span');// 此时在nodep里面继续寻找span标签

注意：找到一个节点不是唯一的，因此，寻找的时候要注意2点，1是寻找效率，2是寻找的“无歧义性”


节点的增加：

1：你要增加什么结点？
2增加在哪儿？

假设在body的container div 里，增加一个p标签？
那就是要：先做一个p节点，然后把p节点放到 div 里去

创建元素节点：
document.createElement;
创建文本节点：
document.createTextNode

给某元素插入一个子元素，并插在最后
节点.appendChild(追加子元素)

insertBefore(nodeli,xi)//第一个参数是待插入节点，第2个参数是定位用的坐标

不仅可以创建节点，还可以复制/克隆一个节点
odlNode.cloneNode(true/false),//代表克隆节点，并同时克隆/不克隆子节点

删除节点：当你某个节点 .nodeN为例，你是无法调用nodeN.XXX()方法把删掉
必须得站在基其父节点的高度，通过removeChild才能删除
父节点 .removeChild(待删除的子节点)

节点的替换:
先创建一个新节点准备，再找到要被替换的旧节点
然后到旧节点的父节点上去，站在父节点的高度上
父节点 .replaceChild(新节点,旧节点);


直接插入html内容[不是w3c的标准，但是主流浏览器支持，而且非常好用]
innerHTML 属性
节点的innerHTML属性是可读可写
读：是把某个节点的内部的thml代码读取出来
如果赋值，则相当于把节点的html代码更新


修改节点的属性
在节点中，一种是直接写在标签内部的属性，见下面示例
<img src="88.gif" alt="abc" title="xxx" />
<input type="text" value="内容" name="cont" />
<input type="checkbox" value="台球" checked="checked" class="aaa"/>

注意：有一个例外
控制元素的类名称的时候，不用obj.class,而是用obj.className

还有一种，是体现css里的属性
style各种css属性，如width,height,border,fontsize

注：
在css中的属性，与js中控制相应的属性，名称有一个对应关系
如background --> style.background,这种情况，js的属性与css的属性名相同即可

如果形如margin-left,font-size这种中间的"-"的css属性，用js来控制时
则属性名 变为marginLeft,fontSize
规律为：把css属性中的"-"去掉，并把"-"后的首字母大写

DOM事件
DOM事件就是指当页面上发生某一件事时候，激发某一个函数
相当于“监听/触发设备”

比如：元素被单击时，用onclick来激发一个函数
元素失去焦点时，用onblur事件
表单被单提交时，用onsubmit事件
注：用onsubmit时，若要阻止事件被提交，除了在函数里写 return false以外，还要在事件处写 return
例：
function t2(){
		alert('请填写完整');
		return false;
	}
<form action="25.html" onsubmit="return t2();">

DOM事件如何声明？
1：直接在元素标签中声明
<input type="text" onclick="fun();" />

2:给事件属性赋上一个函数变量

例：inputobj.onclick = fun;





主要的DOM事件
DOM事件可以归为3类
1：页面上的变化引起的，比如失去焦点，关闭页面
2：鼠标变化引起的，比如鼠标经过，鼠标单击，鼠标双击
3:键盘事件

其中，onsubmit事件比较特殊
在<form onsubmit="return 函数名();" />
这样，函数return false时，才能阻拦住表单的提交行为



==========js操作DOM
节点创建
节点增加
节点删除
节点修改（替换）


创建节点：
元素节点 例：<p></p>
文本节点 例：“我是文本”
属性节点 例：<img src="xxxx" />


创建元素节点：
document.createElement('标签名称');

创建文本节点：
document.createTextNode('文字内容');

节点的增加：
找到其父元素，调用 父元素.appendChild(新节点);

想指定插入在父元素的某个子元素之前
找到父元素，找到定位用的子元素。
调用  父元素.insertBefore(新节点,定位节点)

节点的复制：
节点.cloneNode(true/false); //分别代表复制/不复制 子节点

删除节点：当你某个节点,nodeN为例，你是无法调用nodeN.xxx()方法把删掉
必须得站在其父节点的高度，通过removeChild才能删除
父节点.removeChild(待删除的子节点)

节点的替换
思路：有一个新节点，一个旧节点，还得找到旧节点的父节点
父节点.replaceChild(新节点,旧节点);

直接插入html内容[不是w3c的标准，但是主流浏览器去接，而且好用]
节点.innerHTML  （innerTHML是一个属性，不是一个方法或函数）

=========== js 操作 节点的属性和css属性 ==========

对于<input type="" name="" value="" />
上面type,name,value,这种直接写在节点内部的属性名
js如何操作？
答：先找到该节点，然后 节点.属性名
有一个例外：节点.class ==> 节点.className


对于 css属性
{
	width:200px;
	font-size:14px;
}

如何操作？
答：
找到节点
节点.style.css属性
css属性的命名规律：
如果css属性不含"-",则js中属性与css属性相同
如果css属性含有"-",则js中的相应属性为css属性去掉"-"，并把"-"后的首字母大写

BOM模型 ---> window
BOM浏览器对象模型

document对象其实是window的一个属性或子对象

window对象的子对象介绍:
		window.navigator:表示浏览器的相关信息
		window.history:历史记录，或者控制前进后退
		window.screen:表示分辨率信息
		window.location:地址栏，可以控制页面跳转
		window.documen:DOM模型

window.document,为什么之前的学习中，直接 document. ?
答：因为window对象是最大的一个对象，所有对象都在其内部

写docuemnt，默认就是在最全局 window 下面属性或子对象


window对话框：
alert(): 对话框
confirm():确认对话框
prompt('提示信息','默认值')，提示输入框（用的较小）


window定时器：
window.setTimeout('事件',时间)
是指经过指定'时间'后执行事件一次

window.setInterval('事件','时间')
是指：每隔指定时间，就执行一次事件

清除window定时器

在创建定时器的时候，把创建结果赋给一个'定时变量'
比如：
var clock=window.setInterval();.....
再用
clearInerval(clock);


1:事件对象包含事件相关的信息，如鼠标，时间，触发的DOM对象等
2:事件对象被系统传递给事件函数的第1个参数
3:事件对象的属性在IE/W3C 略有不同
4:一个重要的事件属性：target,srcElement(IE下)，代表事件发生的所在DOM对象

五子棋业务逻辑分析
1：有一个棋盘
2：点击棋盘格子时，格子要显示柜子
3：横向，纵向，某种颜色够5颗后，判定胜负

第1步：棋盘:

建立一个15*15的表格(td)，再给table加一个背景就可以了

2：点击格子时,即td时，给td加一个背景(黑棋或者白棋)
(当点击时，还需要判断该td上是还已有棋子)

完成以上2步，基础的5子棋功能完成


========= 再智能一点，加上判断胜负的功能 =========


========= 学ajax后，在线5子棋 ==========


五子棋技术分析
一：应该画一个棋盘
1：table+背景

二：下棋过程
2：要能点击(td)的时候，表格上在棋子出现

3：在点击td的时候，要能够正确判断当前是下白棋还是黑棋

4：在点击td下棋的时候，要能判断当前td是否为空

三：技术分析
DOM事件 onclick
js操作DOM及css
for循环
if/else

td对象加一个属性，标志是否有枯棋子

四：分析开发步骤
1：没问题
2.1：点击td时候，激发一个函数，该函数只负责alert();
2.2:在2.1的基础上，改进函数，使水alert，而是改变td的css,style,background,为黑棋
2.3:在2.2的基础上，再改进，如果放了黑棋之后，设一个变量，把下一步要下棋的颜色记录下来
2.4:在2.3的基础上，再判断是否已经下过棋了

=====================JS高级========================

作用域

在JS中，函数嵌套是非常普遍的
在函数嵌套中，

对变量是如何寻找的？
答：首先在函数内寻找
寻找不到，则往外层寻找
……
直到……全局(window区域)

var c = 5;

function t1(){
	var d = 6;
	
	function t2(){
		var e = 7;
		// var d = 3; 注释再去掉，观察结果的变化
		alert(c + d + e);
}
t2();
}

t1(); //15 ,18


作用域的测试题:


/*
		作用域考试

		注：这是一具极容易出错，又极基础的JS面试题
    	*/
    	var str1 = 'global';

    	function t1(){
    		console.log(str1);
    		console.log(str2);
    		str2 = 'local';
    	}
    	t1();  // global  str2 is not defined

// ----------------------------------------------------

    	var str1 = 'global';

    	function t1(){
    		console.log(str1);
    		console.log(str2);
    		var str2 = 'local';
    	}
    	t1();  // global  undefined

    	/*
		js代码自上而下执行

		但是------------
		js代码在整体运行分：

		词法分析期
		运行期

		自上而下执行之前，先有一个“词法分析过程”

		以上面的结果为例：

		1步：分析t1函数
		t1{
		var str2   // 分析出t1内有str2局部变量，注意此时函数未执行，因此str2是undefined
		}
		2步：执行t1函数
			console.log(str1);  // global
			console.log(str2);  // undefined
			str2 = 'local';   //此时，str2的值为local
    	*/


















==========================PHP==========================



变量:
1:类型
整型，浮点型，字符串，布尔，数组，对象，NULL，资源

2:变量检测
isset可以检测变量是否存在，
注意:对于NULL，isset也返回false

3:类型检测
gettype() 获取变量类型;

//判断是否我们想要的类型
is_int , is_float , is_array....


apache是一种http服务器软件

4:打印
echo 字符串
print_r 数组
var_dump 打印

5:类型转换
PHP中，变量的类型是可以随时转变的，非常灵活
最常见的是字符串与数字的转换，
或是数字/字符串  >  布尔值的转换
字符串到数字的转换，从左到右截取，直到碰到不合法的数字，截取出来的部分转成数字
// 到布尔开的判断，以下值，都被当成布尔的假，而其他值，都被当成布尔型的真
// '','0',0,0.0.false,NULL,array();

6:赋值
传值赋值，引用赋值

7:销毁
unset(变量名);

8:动态变量名
用变量的值再做变量的名，如$$a;

9:算术运算符
除数不能为0
整型数大到一定程度后，会溢出，转为浮点型
取模算法时，结果的正负仅取决于被除数
$a = 10; //换成10，-10各试
$b = 3; //换成3，-3各试
echo $a % $b; //取模算法时，结果的正负仅取决于被除数

10:比较运算符
//  凡运算，必有运算结果,比较运算符的运算结果是布尔型值  //

11:三元运算符

12:逻辑运算符
&&
||

13:递增运算符
$b = 5;
$a = $b++; //a为5,b为6

$a = ++$b; //a为5,b为6

14:字符串运算符
就是一个 " . ",用于把字符串拼接起来，也可以拼接整型
面试题：下面哪个运算更快？
1：echo $a,$b;
2：echo $a.$b;
答：第一个更快，因为第一个没经过拼接，直接就放在一起了

控制结构
if else

swich(){
    case X:
        语句;
    case X:
        语句;
    case X:
        语句;
	
     ……
    break;
}
//  sweitch case适合用在验证多个可能的值时使用，不适合用在判断范围
//  比如60-80分及格，0-59不及格，81-100优


17:while

while(){

}

给一个条件，如果成立则一直执行，当不成立时跳出

do {

}while()

先执行条件，再判断成不成立，如果成立则继续执行，不成立则跳出

18：for
// 循环的一般要素：初始化，判断，执行体，修改变量
for( , , ,){

}

19：
break(后面的语句不执行) 
continue(跳过该语句，执行后面的语句)


/*

定义格式
functoin 函数名([参数1,参数……N]){
	//执行语句
	//return
}

命名规范：对于函数，命名规则和变量是一样的，但是函数不区分大小写
*/
echo "<br/ >";
echo H2(5,6);

函数的调用过程与返回值
函数调用时，代码执行权进入函数
当函所有语句执行完毕，函数结束，交回执行权
或者函数碰到return语句时，函数返回，交回执行权
返回值可以不返回，就算返回也只能返回一个值

注意：返回值存储在内存中，必须自己通过 echo 才能出现在屏幕上
================= 特别注意 ========================================
function t($a){
	$a += 1;
}
$b = 3;

t($b); // 传参$b的值，赋给$a，而$a是函数内部的值，怎么变，和外界无关

echo $b;
函数中变量的作用域
在PHP的页面中声明的变量，叫“全局变量”
函数内的变量，叫“局部变量”
$a = 22;
function t(){
	echo $a;
}

t(); //会报错
-----------------------------------------------------------------------------

function t2(&$a){  // $a 和 $b指向了同一个地址.
	$a += 1;
}
$b = 5;
t2($b);
echo $b;
// 这种传参方式是不推荐的，因为函数内部的语句，影响到了外部的变量，破坏了函数的封装性


================== 一定理解 ========================================

28：动态调用函数
function wel(){
	echo 'welcome';
}
function beat(){
	echo 'beat';
}

$heart = 'wel';
$heart(); //$heart的值是wel,因为调用执行wel();

29:时间戳
时间戳是指自1970 01 00:00到现在这一瞬间经过的秒数.
echo time(); //返回时间戳 

30:时间戳格式化
date();
如果要输出年 月 日，星期 时 分 秒,格式为：
$time = time();
echo date('Y-m-d 星期N h:i:s',$time);
echo date('Y-m-d 星期N h:i:s'); // 如果不要第二个参数，那么将会默认为现在的时间
echo date('Y-m-d 星期N h:i:s',0); //如果第二个参数为0，那么将会为时间戳的初始时间(但是会有时差)即:1970-01-01 星期4 01:00:00

gmdate();
echo gmdate('Y-m-d 星期N h:i:s',0); //gmdate不分时区，以格林威治时间为标准

// 31:解析检测日期
// mktime();
// strtotime();
// checkdate();

echo mktime(22,22,20,9,24,2014);//如果不输入参数，系统将会以此刻的时间为标准输出
echo '<br />';

echo strtotime('now'),'<br/ >'; //这个函数是语义性，可以直接输入具有语义性的单词

echo strtotime('now +1 day'),'<br />';

echo strtotime('now - 1 day');


// heredoc nowdoc定义大段文本
// heredoc 定义大段文本
$str3 = <<<INTRO  // "INTRO"是可以自己定义的。里面的一大段内容是自己写的
hello
world  abc
	ok now;
INTRO;

//nowdoc 定义大段文本

$str4 = <<<'INTRO' // 加 '' 就是nowdoc
远看山有色,
近听水无声
INTRO;

echo $str4;

heredoc 和 nowdoc的区别就是单引号和双引号的区别

单引号不能解析变量，双引号能解析变量。单引号只能解释部分转义字符，双引号能解析所有字符

单引号不需要分析串内有没有变量，需要转义的内容也少，速度比双引号要快。
我们优先使用单引号

strlen($str); // 表示的是字符串在内存中占的字节个数(一个汉字占6个字节)
mb_strlen($str,'utf-8'); // 以字符来计数，不是以字节来计数（需要声明用的是什么编码）例：$str = '中国'; echo mb_strlen($str,'utf-8'); 会输出2，并不是6

strrpos(字符串 , '要查找的字符串' , 从第几位开始 ); // 查找字符串中要查找的字符串最后出现的位置

stripos(字符串 , '要查找的字符串' , 从第几位开始 ); // 查找字符串中要查找的字符串第一次出现的位置

// 替换字符串
str_replace('要搜索的字符串', '替换后的字符串', '被搜索的原字符串' );


// 替换一批字符串
strtr(字符串,array('替换' => '被替换','替换' => '被替换'));

// 截取子字符串
substr(字符串,开始位置,结束位置);//如果为负数，则是从后面开始数到前面

// 拆分字符串
$str = 'tech,linux,mysql';
$arr = (explode(',', $str));// 把字符串组装成数组
print_r($arr);
echo '<br />';
echo implode($arr,',');// 把数组拆分成字符串

//数组
$arr = array('a','b','c','d');
echo array_push($arr, 'e'),'<br />'; //往数组尾部加入单元，并返回操作后的数组长度

//弹出数组最后一个单元
echo array_pop($arr),'<br />';// e

//在头部新增一个单元，输出长度
echo array_unshift($arr, 'z');// 在头部增加一个'z'

//弹出数组的第一个单元
echo array_shift($arr);// 弹出头部单元

//取当前游标指向的数组单元的值
current($arr);
//把数组的游标往后移
next($arr)
//把数组游标移到最后
end($arr)
//把数组游标前移
prev($arr);
//重置数组游标
reset($arr);

数组常用函数:
count();//取出数组的个数
isset();//判断有没有值或操作
arry_key_exists('值',$arr)//查找数组里有没有这个键
in_array('值',$arr)//判断数组里有没有这个单元





/*n只猴子围坐成一个圈，按顺时针方向从1到n编号
然后从1号猴子开始沿顺时针方向从1开始报数，报到m的猴子出局，
再从刚出局猴子的下一个位置重新开始报数，如此重复，直至剩下一个猴子，它就是大王
设计并编写程序，实现如下功能：
（1）要求由用户输入开始时的猴子数n，报数的最后一个数m
（2）给出当选猴王的初始编号
*/

文件包含
文件包含的作用在于代码的重用。
我们可以把常用的代码段写一个文件里
当需要这些代码时，引入这个文件就可以了.

include include_once
require require_once

include require 的区别
如果引入文件不存在，
include尽量往下执行，报waring
require则直接报fatal error,脚本立即停止执行

_once作用：只引入一次，如果之前已引用过，不再重复引用

进制：

10进制        2进制
  5            0000 0101
  255          1111 1111,128+64+32+16+8+4+2+1
  -1           1111 1111
  像上面8个1，到底理解成255，还是理解成-1
  这个取决于程序
  比如在mysql中，int则理解为-1，unsigned int理解为255


bindec(); 二进制转换为十进制
decbin(); 十进制转换为二进制
dechex(); 十进制转换为十六进制
decoct(); 十进制转换为八进制
hexdec(); 十六进制转换为十进制
octdec(); 八进制转换为十进制

base_convert(); 在任意进制之间转换数字

例：
$g = 2;
echo base_convert(  $g  ,  10   ,  2);
                  要转换  转换前  转换后
		  的变量  的进制  的进制


PHP把不同等级的级别，用数字来表示，比如

1 E_ERROR(integer) 致使的运行时错误。这类错误一般是不可恢复的情况，例如内存分配分配导致的问题。后果是脚本停止运行
2 E_WARNING(integer) 运行时警告(非致使错误)。仅给出提示信息，但是脚本不会终止运行

递归练习：
1：一个多维数组，如果单元值为数字，则把其值修改为原来2倍
如array(1,2,'b',array(3,'c',array(4,5)));
变成
array(2,4,'b',array(6,'c',array(8,10)));
// 在对POST,GET做递归安全转义时要用到

2：递归创建级联目录
如给定 './a/b/c/d/e',而./a都不存在，要能递归创建
// 项目中经常按 年/月/日 这种 格式来创建目录，并存在上传文件

3：递归删除目录
如给定 './a',则要把a目录及下级子目录，全删除
// 后台管理系统中，会批量删除某个目录

4：给定如下数组，完成无阻级分类
array(
    array('id'=>1,'area'=>'北京','pid'=>0),
    array('id'=>2,'area'=>'河北','pid'=>0),
    array('id'=>3,'area'=>'保定','pid'=>2),
    array('id'=>4,'area'=>'易县','pid'=>3),
    array('id'=>5,'area'=>'海淀','pid'=>1),
)


要求：写函数得到如下结果
f(0) 输出 0 号地区下的子孙地区
北京
    海淀
河北
    保定
        易县
f(2)得到2号地区下的子孙地区
河北
    保定
        易县

无限级分类

===============================MySQL=================================
insert 所有列
insert指定列				insert into 表名
注意：列与值，严格对应			(列名) values (行数据);
数字和字符串的注意点			
数字不必加单引号，字符串必须加单引号


update
改哪张表？                              update 表名 set
你需要给改哪几列的值？分别改成什么值？  列1 = 新值1,列2 = 新值2               
在哪些行生效？                          where expr
 
delete
你要删哪张表的数据？                    delete from 表名
你要删掉哪些行？			where expr


select
查哪张表的数据？                        select 列1,列2,列3....列n from 表名
你要选择哪些列来查询？			where expr
要选择哪些行？

在一张表中，列是变量
变量可以计算
where是表达式，值为真假


		truncate:清空一张表的数据
		例：truncate msg;
	 	     清空   表名

改表名:
rename table oldTableName to newTableName


自增语句:
字段名 类型
id int primary key auto_increment

对于mysql_query发送select语句，返回值是资源型

======================MYSQL运算符=======================

运算符       说明        运算符         说明
 <           小于        !=或<>         不等于
 <=        小于或等于     >=          大于或等于
 =           等于          >             大于
 in        在某集合内    between      在某范围内
--------------------------------------------------------

逻辑运算符

  运算符          说明
 NOT 或 !        逻辑非
 OR 或||         逻辑或
 AND 或 &&       逻辑与

----------------------------------------------------------
模糊查询

like模糊匹配
% 通配任意字符
_ 通配单一字符

-----------------------------------------------------------

查询NULL:  例：select * from goods where goods_name is NULL; //在查询NULL时，一定用is,而不是 '='符号。
查询不是NULL：例：select * from goods where goods_name is not NULL;




MYSQL函数：

floor(浮点数)------------------------------------------只取浮点数的整数位

substring(变量,截到第几位)-----------------------------截取字符串

concat('字符串','字符串','字符串','.......')-----------拼接字符串



group分组与统计函数:

avg(变量)----------------------------------------------求平均值
例：select avg(shop_price) from goods;

max(变量)----------------------------------------------求最大值
例：例：select max(shop_price) from goods;

count(变量)--------------------------------------------求行数
例：例：select count(shop_price) from goods;

min(变量)----------------------------------------------求最小
例：例：select min(shop_price) from goods;

sum(变量)----------------------------------------------求总和
例：例：select sum(shop_price) from goods;

group by:分组，和where一样，也是条件语句
例 分组查询价格：select cat_id,shop_price from goods group by cat_id;


order by排序
降序 desc
升序 asc[默认是]
多列排序 在字段后面加逗号即可

例：select goods_id,cat_id,goods_name,shop_price from goods order by cat_id asc,shop_price desc;

limit限制取出的条目

带有两参数 limit 要跳过的参数，读取的行数

例：select goods_id,cat_id,goods_name,shop_price from goods order by cat_id asc,shop_price desc limit 0,3


子句的查询陷阱

5种子句是有严格的顺序, where,group by,having,order by,limit


where型子查询
作为外部查询的条件
例：select goods_id,goods_name from goods where goods_id=(select max(goods_id) from goods);


from型子查询
根据已询出的表，再次查询

例：select goods_id,goods_name from (select * from goods where 1 order by cat_id asc,goods_id desc) as tmp group by cat_id;


exists 型子查询
判断是否有该变量，有就要，没有就不要

例：select * from category where exists(select * from goods where goods.cat_id=category.cat_id);


内连接：join 连接

关键：两表相连用  inner join   连完后用 on 后面接条件

			 girl表下的hid和bname 			on表示连接条件  
例：select boy.hid,bname,girl.hid,gname from boy inner join girl on boy.hid=girl.hid;
	 boy表下的hid和bname                boy和girl表相连用'inner join'   


左连接：
以左边数据为准，查询右边相关数据，查不到的补 NULL。

例：select boy.hid,bname,girl.hid,gname from boy left join girl on boy.hid=girl.hid;
					   以左表为准查询右表
注：左表数据会全部显示，如果和右表有相关数据，右表会对应左表的相关条件出现，否则右表会显示 NULL

右连接：
和左连接性质一样，右连接就是以右边相关数据为准，查询左边数据，左边查不到的数据补 NULL

例：select boy.hid,bname,girl.hid,gname from boy right join girl on boy.hid=girl.hid;



两张表
如果用 内连接，只会查询出两张表某条件相同的数据
如果用 左连接，会查询出左表所有数据，和左表与右表在某条件下相同的数据
如果用 右连接，会查询出右表所有数据，和右表与左表在某条件下相同的数据


union查询：
就是把2条或多条sql的查询结果，合并成1个结果集

sql1 N行
sql2 M行
sql1 union sql2 ,N+M行

场景：2条语句，各自的where条件非常复杂，可以简化成简单条件，再union

union的语句必须满足1个条件：各语句取出的列数相同
列名称未必要一致，列名称会使用第1条sql的列名称为准

注意：使用union时，完全相等的行，将会被合并
合并是比较耗时的操作
一般不让union进行合并，使用"union all"可以避免合并

讨论：union的子句中，不再写order by
sql合并后得到的总的结果，可以order by，子句order by 失去意义


=====================================MYSQL 建表======================================

建表过程，就是一个画表头的过程（就是一个声明字段的过程）

列 选 什么类型的列？？
 列给什么样的属性？？

列的类型与其属性的相关知识

create table 表名(
列1 列类型[列属性 默认值],
列2 列类型[列属性 默认值],
……
列n 列类型[列属性 默认值]
);

engine = 存储引擎
charset = 字符集

开发技巧：定长与不定长分离，常用与不常用分离


列的数值类型：

数值型---整形，浮点型，定点型
字符串---char,varchar,text
时期时间类型


整型列

类型        字节         最小值         最大值
	         (带符号的/无符号的)(带符号的/无符号的)
TINYINT       1           -128           127
                          0              255
SMALLINT      2           -32768         32767
                          0              65535
MEDIUMINT     3           -8388608       8388607
                          0              16777215
INT           4           -2147483648    2147483647
                          0              4294967295
BIGINT        8           -922337203…………z…天文数字

默认是带符号的

unsigned:无符号，列的值从0开始，不为负
zerofill:适合用于 学号，编码等，固定宽度的数字，可以用 0 填充至固定宽度

思考：zerofill填充至多宽？M
注意：zerofill属性默认决定列为 unsigned

整型列的可选参数


浮点列与定点列

float(M,D)，M是精度总位数，D标度，小数点后面的位数
     (5,2)

double 和float区别：能够存储的数据更多 (有精度损失)

decimal 定点型，更精确

char(10) ,定长（速度快些）
10个字符
1个字符，还是10个字符的宽度

char型，如果不够M个字符，内部用空格补齐，取出时再把右侧空格删掉
注：这意味着如果右侧本身有空格将会丢失

varchar(10),会额外再占几kb的空间，利用率不能达到100%
最长10个

技巧：如果开发中，数据占的空间很小，就用cahr，能最大地利用存储空间，如果数据占空间很大，就是varchar

blob，是二进制类型，用来存储图像，音频等二进制信息
意义:2进制，0-255都有可能出现
blob在于防止因为字符集的问题，导致信息丢失
比如：一张图片中有0xFF字节，这个在ascii字符集认为非法，在入库的时候，被过滤了

enum 枚举型，是定义好，值就在某几个枚举范围内 
gender('男','女'),insert时，只能选"男","女"

set('value1','value2'……)有集合的意思，insert时可以插入一个或多个


日期时间类型

year:年(1字节)
在insert时，可以简写年的后2位，但是不推荐这样

date日期，例：1998-12-31
范围:1000/01/01,9999/12/31

time 时间
范围：-838:59:59 -->838:59:59

datetime 时期时间 
范围：1000/01/01 00:00:00 ---> 9999/12/31 23:59:59

时间戳：
是1970-01 00:00:00 到当前的秒数
一般存注册时间，商品发布时间等，并不是用datetime存储，而是用时间戳
因为datetime虽然直观，但计算不便


列的默认值
1：NULL 查询不便
2：NULL的索引效果不高
所以实用中，避免列的值为NULL

如何避免，声明列 NOT NULL default 默认值


主键与自增

主键：primary key,此列不重复，能够区分每一行！
自增：auto_increment
注意：一张表，只能 1 列为auto_increment,且此列必须加索引(index/key)

create table t11(
id int primary key,
name char(2)
);

create table t12(
id int,
name char(2),
primary key(id)
);

create table t13(
id int auto_increment,
name char(2),
key id(id)
);



create table regist3(
id int unsigned primary key auto_increment,
Username char(10) not null default '',
gender tinyint not null default 0,
weight tinyint unsigned not null default 0,
birth date not null default 0,
salary decimal(8,2) not null default 0,
lastlogin int unsigned not null default 0
);

create table regist1(
id int primary key auto_increment,
Username char(10) not null default '',
intro varchar(1500) not null default ''
);

==============列的增删改==============

增 alter table 表名 add 列名 列类型 列属性...默认在表的最后
增 alter table 表名 add 列名 列类型 列属性...after 列名(将会出现指定列后)
删 alter table 表名 drop column 列名
改 alter table 表名 change 列名 要修改的列名 要修改的类型
改 alter table 表名 modify 列名 新属性.....

=============视图=====================

视图：view
view 又被称为虚拟表，view是sql的查询结果

有什么用？
1：权限控制时可以用
比如某几个列，允许用户查询，其他列不允许
可以通过视图，开放其中一列或几列，直到权限控制的作用

2：简化复杂的查询
查询每个栏目下商品的平均价格，并按平均价格排序，查出平均价前3高的栏目

3：视图能不能更新，删除，添加？
答:如果视图的每一行，是与物理表一一对应的，则可以
view的行是由物理表多行经过计算得到的结果，view不可以更新的

视图放哪儿？(存的仅仅只是一条语句)
对于简单的查询形成的view，再对view查询时，如where,order等等
可以把建视图的物理语句+查视图的语句=======合并成===>查物理的语句
这种视图的算法叫marge（合并）

也有可能，视图的语句本身比较复杂，很难再和查询视图的语句合并，mysql可以先执行视图的创建语句，把结果集造成内存中的临时表
然后再去查临时表(temptable)


查看所有表 show tables;
查看表结构 desc 表名/视图名
查看建表过程 show create table 表名
查看建视图过程 show create view 视图名
查看某张表详细信息 show table status where name='表名' (如果加上\g，就会竖着显示）
查看所有表详细信息 show table status
删除表 drop table 表名
删除视图 drop view 视图名
改表名 rename table oldName to newName
清空表数据 truncate(相当于删除表，再重建)


查看数据库里的字符集设置：
show variables like '%charact%';

设置字符集的编码，不再乱码：

1:PHP或HTML页面设置 meta charset="utf-8"
2:数据库里建表时设置
create table(
)charset utf8;

3:连接数据库时：set names utf8;
4:页面信息编码 utf8


索引是数据的目录，能快速定位数据的位置
索引提高了查询速度，降低了增删改的速度
一般在查询频率的列上加，而且在重复低列上加效果更好

key:普通索引
unique key:唯一索引 (一个网站，如果用户名或email等不能重复，可以用唯一索引，提高速度)
primary key:主键索引
fulltext：全文索引 (中文环境下，全文索引无效，要分词+索引，一般用第三方解决方案，如sphinx)

索引长度：建索引时，可以只索引列的前一部分的内容，比如，前10个字符
如key email(email(10))

多列索引，就是把2列或多列的值，看成一个整体，然后建索引

索引原则：左前缀
例：abcdefg,如果查abc，则可通过前面的abc查到，但是要查fg,只就不能，因为fg的前面或许有别的字符，如zzzaaa

冗余索引，就是在某个列上，可能存在多个索引
比如 xm(xing,ming),  ming(ming)



索引操作:

查看：show index from 表名

删除：alter table 表名 drop index 索引名 或 drop index 索引名 on 表名

添加主键索引:
alter table 表名 add index/unique 索引名(列名);

删除主键索引
alter table 表名 drop primary key


事务概念：
(隔离性,原子性,一致性,持久性)
当这一端事务开始时，另一端无法看到中间事务(就是操作过程),只有事务结束后，能看到事务操作后的结果

事务开始：
start transaction

事务回滚(返回上一次的操作)
例：当后悔这个操作时，可以用这个命令撤销这个操作,但是事务结束后，就不能这样了
rollback

事务结束：
commit


======================================面向对象=======================================

以女娲造人为例
女娲看到人间冷清，于是在水中照见自己的形象
并在自己的形象基础上构思，加上2条腿

动手捏泥人

思考问题1：在泥人产生之前，先产生的是“女娲在脑子中构造的人的形象”
然后根据形象来捏人

思考问题2：
捏的人 都有一个什么特点------和人的形象相符


换句话说：
人的形象 是抽象的，用来说明人的共同特点的
而每一个人，是具体的，且符合形象的描述


类：就是所有对象共同点的一个抽象
就是一个-----制造说明书！

对象：就是根据说明书造出来的具体对象


====买一个四层书柜
原以为是现成书柜，送来贷后发现是  说明书+板子+螺丝
说明书上说清了 A板 B板...如何结合
并画了一张图，就是组装成功后的图

我照着图----最终组装一个书柜

说明书---就是类
书柜-----就是对象

???如果原材料非常多，我造1000个书柜
需要几份说明书
答：还是1份

==================如果我们在PHP中用面向对象的话==============
想造N个人的对象，
需要先：创建人类，且只需要创建1次
然后再：由类创造人的对象，可以N次


从对象中，我们归纳出来了什么？（类中有什么？）

有什么？ 属性（身高，体重，姓名）
能干什么？ 功能（哭，笑，招呼，吃饭）


====如何声明类=======
我们用"变量","函数"来模拟"属性"/"功能"

我们把{N个属性+N个方法}打包成一个"东西"---就是对象
其实就是N个变量，N个函数，打包到某个对象里
这个对象可以使用这N 个变量N个函数


=======================================
再从程序的角度/数据的角度深入分析类与对象

声明类时的注意事项
[重要]创建对象时，到底发生了什么

=======================================

构造函数 __construct();注意 前面是两个下滑线

构造函数的作用时机：
每当new一个对象，就会自动对新new出来的对象发挥作用

new ClassName($args);
$args参数原样传给构造方法
然后构造方法，用参数来影响创建的对象

当然 :new ClassName() 也可以不传参

但注意：$args要与构造方法里的参数一致

析构函数: __destruct()

构造函数是在对象产生的时候，自动执行
析构函数是在对象销毁的时候，自动执行

构造函数是出生时啼哭
析构函数是临终遗言

注意：析构函数，如果值被unset掉或者被赋一个别的值，都会触析构函数

对象如何销毁？
1：显示的销毁，unset，赋值为NULL都可以
2：PHP是脚本语言，在代码执行到最后一行时，所有申请的内存都释放掉
自然，对象的那段内存也要释放，对象就被销毁了

对于PHP所做的WEB程序，想犯内存泄露的错误，也很难

对象的销毁是指object的销毁
就像一间房子推平一样
$a,$b,$c,$d，就像指向这间的钥匙


========对象的引用传值============
$a = new Obj();
$b = $c = $d = $a;
对象默认是引用传值，也就是说，$b,$c,$d,$a都指向同一个对象
所以当所有变量都被销毁时，这个对象的析构函数也只会被激发一次




this绑定：

当一个对象调用其方法时，
在该方法执行之前，先完成一个绑定

$this--->绑定到调用此方法的对象

例：
class Human{
	public $name = 'lisi';

	public function who(){
		echo $this->name;
	}
	public function test(){
		echo $name; //如果不加$this,这里会理解为方法里的局部变量
	}
}

$a = new Human();
echo $a->name;  // lisi
$a->who(); // lisi


$b = new Human();
$b->name = 'zhangsan';
echo $b->who(); // 'zhangsan';

$c = new Human();
$c->name = 'wangwu';
echo $c->who(); // 'wangwu';


 ==========回顾==========

构造函数  __construct()
在new对象时，自动执行

new对象时，
1：申请内存，生成对象（属性集合）
2：如果有构造函数，则执行
3：返回该对象地址

析构函数 __destruct()
对象销毁时执行
什么叫对象销毁？
答：$a = new Human();
$a 并不是对象，他只是一个变量名，指到对象
unset($a)未必销毁了对象

我们知道，一个对象如果还有其他变量来引用，unset($a)并不会销毁 
当引用为0时，对象才销毁


$this指向调用方法的对象
$a->say();
say(){}函数体内的$this---->$a

注意：方法内，存取对象的属性时，必须用$this
这点和java,c#不一样

==================================================================================
 看看权限控制的BUG

李四读取和改变张三的钱，
这如果从生活角度来看，是不合理的

钱私有，是指 "每个对象的钱，针对每个对象私有"
即：张三的钱，由张三->showMoney才能引用

李四不应该有权直接引用
或者说，李四->showMoney,也只有权引用 李四自己的money属性

但是，在上面的代码中，李四却显然引用和改为张三的钱
这是因为：
PHP在实现上，并不是以对象为单位来控制的权限
而是以类为单位，来控制的权限,
所以前一页，不断强调，类内，类外，而不是说对象内，对象外

因为 类声明一次，而对象却可能非常多
以类为单位，简单了判断模型


第三，从代码来看
zend引擎
ce==EG(scope)
这一句判断的是
调用者属性的类 与 执行上下文所属的类 是否相等


在我们判断中：
$lisi-->类-->Human类
$lisi->setMoney()函数，也是Human类中。
在同一个类内部，可以调用

这也说明了，确实是以类为单位，以类内类外为界限做的判断


第四：从其他语言来看一看这个问题
java c#也存在这个问题

第五：从面向对象的角度来考虑
我们的写法，也有问题
就不应该把一个对象，直接传给一个方法来使用

而应该 zhangsan borrow钱
应该对应 lisi   sent钱
即 应该尽量的来调用对象的方法，而不应该直接把对象当成参数给传过去


================================================================================


===回顾===
封装的概念:
可以通过权限修饰符，把某些属性封装在类内部
并通过指定的公共接口来访问

钱->别人不能拿，可以借

还有，调用某个公共方法时，该公共方法可能调用在内部多个方法。
但是调用者不需要知道内部的调用过程
借钱<-借到500，但背后可能已经拿现金+去银行取+卖家当凑齐的

private与public
如何区分：
就看调用私有private属性/方法的那句话，
发生在类的{}内，还是类的{}外

================================================================

对于子类继承父类的protected/public属性/方法

1:父类有的 子类继承
2:父类有的 子类可以更改
3:父类没有 子类可以添加

私有的属性，可以理解不能继承(其实能继承过来，只不过无法访问)

public protected private中，
public protected 都可以继承，并拥有访问和修改的权限
这就好比说，家产已经继承了，愿意卖就卖，愿意改就改

而私有的，就像先祖的牌位，继承下来
但是无权动，只能供着


/*****************************

构造方法的继承

答：构造方法也是可以继承的
而且继承的原则和普通方法一样

进而，如果子类也声明构造函数，则父类的构造函数，被覆盖了！
如果父类构造函数被覆盖了，自然，只执行子类中新的构造函数

引发一个问题：
如果是一个数据库操作类，或者model类
我们肯定是要继承过去再使用，不能直接操作model类
而model类的构造函数，又做了许多初始化工作

我重写的model类的构造函数之后，导致初始化工作完不成了，怎么办？
答：如果子类继承时，子类有构造函数，保险一点，调用parent::__construct

这一点和java的面向对象，也有不同。
在java中，实例化子类时，父类的构造函数运行，且先运行
然后运行子类的构造函数


另外：java中构造函数不是 __construct(),而是和类名相同的方法理解为构造函数
在一些比较老教材或者老的代码中，也有可能有这种情况
即 与类名相同的函数做构造函数-----这是PHP时代的残留

请记住，不要这样写


class Mysql{
	protected $conn = NULL;
	public function __construct(){
		$this->conn = mysql_connect('localhost','root','123456');
	}

	public function query($sql){
		return mysql_query($sql,$this->conn);
	}
}

$mysql = new Mysql();
var_dump($mysql->query('use test')); // true,query成功

class MyDb extends Mysql{
	public function __construct(){
		//如果父类有构造函数初始化，那么,如果子类继承时，有构造函数，先写 parent::__construcet 保险一点.
		// 否则会把父类的构造函数覆盖了
		parent::__construct();
		// 然后再写自己的业务逻辑
		// ……………………………………
	}
	public function autoInsert(){
		$this->query('use test');
	}
}
$mydb = new MyDb(); // 看看问题出在哪儿？
var_dump($myDb->autoInsert());

******************************/

继承的特点：

subClass extends parentClass {

}

继承的特点：
对于protected/public类型的属性/方法
完成继承过来，有权重写，调用

继承过来的属性/方法：
父类有的，子类也有
父类有的，子类可以改写
父类没有的，子类可以添加

对于pricate类型的属性/方法，比较特殊
可以继承过来，但有个标记，标记记从属父类而来
即 在子类内是无权调用继承过来的私有属性/方法的

构造方法的继承
构造方法也是可以继承的
new子类时，如果构造方法继承过来，当然也要自动执行
但继承过来，子类重写了，自然执行子类的构造方法
（注意，父类的构造方法不再调用）


private
protected
public
三者的区别

	  private 	protected 	public
本类内    y 		y 		   y
子类内 	  n 		y 		   y
外部	  n 		n 		   y

注意：在java中，如果属性/方法前面不写任何参数 public/protected/private都不写，也是可以的frirendly
在PHP中，如果public/protected/private如果都不写
则理解为 public 建议养成好习惯，不要不写


=============多态===========

java中，为什么需要多态？
答：因其是强类型语言
参数声明的类型，传参数必须是该类型

声明参数时，声明为父类型
传参时，传其子类型

这样，传不同的子类
有不同的效果
实在是灵活多了---多态

分析 与JAVA那段出错程序相比
PHP没报错
因为PHP是弱类型动态语言

一个变量
$var = 8;
$var = 'hello';
$var = new Pig();

一个变量，没有类型，你装什么变量都行

同理，传参，参数也没有强制类型
传什么参数都行

所以，对于PHP动态语言来说，岂止是多态，简直是变态

别急，不需要PHP那么灵活

Catchable fatal error: Argument 1 passed to Light::ons() must be an instance of RedGlass, instance of BlueGlass given, called in D:\www\class\1109_05.php on line 49 and defined in D:\www\class\1109_05.php on line 5

加了类型检测后，果然传蓝玻璃不行

解决：参数定为父类，传其子类

哲学：子类是父类，例：男人是人，白马是马，蓝玻璃是玻璃

里氏代换：原能用父类的场合，都可以用子类来代替.

如果按PHP本身特点，不检测类型，
本身就可以说是多态的，甚至变态的

但是PHP5.3以后，引入了对于对象类型的参数检测
注意:只能检测对象所属的类

其实，这对于PHP来说，限制了其灵活性,达到的JAVA中多态的效果

反思多态：
其实就是
只抽象的声明父类，具体的工作由子类对象来完成
这样，不同的子类对象完成，有不同的特点

=================================


静态属性与静态方法

从内存角度看
static属性，存放在类的区域中
普通属性，存放在对象中

推导出2点：
1：类声明完毕，该属性就存在
2：因为类在内存只有一个，因此静态属性，有1个

普通属性包在对象内，用对象->属性名 来访问
静态属性放在类内的,

静态属性既然存放于类的空间内
1：类声明完毕，该属性就已存在，不需要依赖于对象而访问
2：类在内存中只有一个，因此静态属性也只有一个


静态方法
static public/protected/private function t(){
}

普通方法，存在于类内的，只有1份
静态方法，也是存放于类内的，只有1份

区别在于：普通方法需要对象去调动，需要绑定this
即，普通方法，必须要有对象，用对象调动

而静态方法，不属于哪个对象，属于类，因此不需要去绑定this,
即，静态方法，通过类名就可以调动


类->访问->静态方法     可以
类->动态方法 方法内没有this的情况下，但严重不支持，逻辑上解释不能

对象-->访问动态方法    可以
对象-->静态方法        可以


=============回顾==============
static 修饰的静态属性 与 静态方法

静态属性：存储在类空间，类声明完毕即存在，不依赖于对象.(在内存中只有一份)

静态方法：静态方法，不绑定$this


=================单例模式=================

这个不好做笔记，详见作业练习里的 class/1112_04.php和1112_05.php和1112_04_test.php和singel test.php

final 最终的
这个关键词 在PHP中，可以修饰类，方法名，但不能修饰属性

final 修饰类，则此类 不能够被继承

final 修饰方法此方法不影响继承，但是此方法 不允许重写


==昨天内容回顾==
self:本类
parent:父类

单例模式：
主要思路
1：保护或私有构造函数，防止外部实例化
2：内部开放一个公共静态方法，负责实例化
3：类有一个静态属性存放对象

当静态属性已经存放对象，直接return该对象

====魔术方法=====

魔术方法：
是指某些情况下，会自动调用的方法，称为魔术方法
PHP面向对象中，提供了这几个魔术方法
他们的特点，都是以双下划线 __开头的

常用的魔术方法:
__call(),__callStatic(),__get(),__set(),_isset(),__unset()

可以总结出：
当我们调用一个权限上不允许调用或不存在的属性时，
__get魔术方法会自动调用，
并且自动传参，参数值是属性名

例：age属性无权调用，则自动调用 __get()方法，
且把age以参数形式传给 __get


总结出 __set的作用
当设置对象 无权操作的属性赋值时，
或不存在的属性赋值时，
__set()自动调用

且自动传2个参数 属性 属性值
例：
$hmm->age = 28 ---无权---> __set('age',28);


__isset() 方法，
当 isset() 判断对象不可见的属性时(protected/private/不存在的属性)
会引发 __isset()来执行

问：isset($obj->xyz) 属性，为真
能说明 类声明了一个xyz属性吗?
答：不能

__unset()方法
当 用unset 销毁对象的不可见属性时，
会引发 __unset();

unset($hua->tail)-----没有tail属性---->__unset('tail');

参考class\1113_02.php文件，里面是魔术方法的应用

__call()方法
当调用不可见（不存在或无权限）的方法时，自动调用
$lisi->say(1,2,4);------没有say()方法--->__call('say',array(1,2,3))运行

__callStatic 是调用不可见的静态方法时，自动调用
Human::cry('a','b','c')----没有cry方法--->Human::__callStatic('cry',array('a','b','c'));


====昨天====
魔术方法

__get
__set
__isset
__unset
__call
__callStatic
__clone


====重载和重写=====

重写/覆盖  override
指：子类重写了父类的同名方法

重载：overload
重载是指：存在多个同名方法，但参数类型/个数不同
传不同的参数，调用不同的方法

但是在PHP中，不允许存在多个同名方法
因此，不能够完成java，c++中的这种重载

但是，在PHP中，能达到类似的效果

可以通过func_get_args()来达到重载效果

例：
class Calc{
	public function area(){
		// 判断一个调用aera时，等到的参数个数
		$args = func_get_args( /*这里面是数组*/ );
		if (count($args) == 1) {
			return 3.14 * $args[0] * $args[0];
		}else if (count($args) == 2) {
			return $args[0] * $args[1];
		}else{
			return '未知图形';
		}
	}
}

$calc = new Calc();

// 计算圆的面积
echo $calc->area(10),'<br />';

//计算矩形的面积
echo $calc->area(5,8),'<br />';

类常量：
const

普通常量   define('常量名',常量值)
以前说过：define定义的常量，全局有效
无论是页面内，函数内，类内，都可以访问

能否定义 专门在类内发挥作用的常量
专门在类内发挥作用  说明
1：作用域在类内，类似于静态属性
2：以是常量，则不可改

其实就是"不可改变的静态属性"

类常量 在类内用 const 声明即可
前面不用加修饰符
而且权限是public的，即外部也可以访问

例：
define('ACC','Deny');

class Human{
	const HEAD = 1;

	public static function show(){
		echo ACC,'<br />';
	}
}

Human::show();


echo Human::HEAD;

魔术常量:

1：无法手动修改他的值，所以叫常量
2：但是值又是随环境变动的，所以叫魔术

---魔术常量
__FILE__  返回当前文件的路径
在框架开发或者是网站初始化脚本中，用来计算网站的根目录

__LINE__  返回当前的行号
在框架中，可以用在debug时，用来记录错误信息

__LCASS__ 返回当前的类名

__METHOD__ 返回当前的方法名

例：
echo '当前正在运行的是',__FILE__,'文件','<br />';

echo "当前在",__DIR__,'目录下<br />';

echo "hi,我在",__LINE__,'行<br />';
echo "hello,我在",__LINE__,'行<br />';
echo "hehe,我在",__LINE__,'行<br />';

class Human{
	public static function t(){
		echo '你正在运行',__CLASS__,'类<br />';
		echo "下的",__METHOD__,"方法<br />";
	}
}

Human::t();


后期绑定/延迟绑定(没有重点讲)

主要是static在子类和父类里的用法
例：
class Human{
	public static function whoami(){
		echo "来自父类的whoami在执行<br />";
	}
	public static function say(){
		self::whoami(); // 子类内没有say方法，找到了父类这里
						// 在这里的self 指的是 父类
	}
	public static function say2(){
		static::whoami(); // 子类也没有say2方法，又找到父类这里
						  // 但是父类用static::whoami,
						  // 指调用你子类自己的whoami方法
	}
	public static function say3(){
		static::whoami();
	}
}
class Stu extends Human{
	public static function whoami(){
		echo "来自子类的whoami在执行<br />";
	}
}

Stu::say();
Stu::say2();
echo "<hr />";
Human::whoami();
echo "<br />";
Stu::say3();


=====抽象类=====

抽象类：无法实例化
类前加abstract,此类就成为抽象类，无法实例化

总结：
类前加 abstract 是抽象类
方法前加 abstract 是抽象方法

抽象类 不能 实例化
抽象方法 不能有 方法体(也就是不能有大括号)

有抽象方法，则此类必是 抽象类
抽象类，内未必有抽象方法

但是 ---- 即便全是具体方法，但类是抽象的，
也不能实例化


抽象类的意义：

请看如下场景：
Facebook 多国言语欢迎页面

user登陆，有一个 c 字段，是其国家
当各国人登陆时，看到各国语言的欢迎界面

我们可以用面向过程来做

if($c == 'china'){
	echo '你好，非死不可';
}else if($c == 'enlish'){
	echo 'hi,welcome';
}else if($c == 'japan'){
	echo '搜达斯内';
}

反思：当facebook进入泰国市场时，
增加 else if ,扩展性很差

/*=======用面向对象来做======*/

abstract class Welcome{
	public abstract function wel();
}

// 再看首页开发者

$c = 'english';// china/japan

$wel = new $c();
$wel->wel();

class china extends Welcome{
	public function wel(){
		echo "你好。。。。。";
	}
}

class english extends Welcome{
	public function wel(){
		echo "hi......";
	}
}

class japan extends Welcome{
	public function wel(){
		echo "搜.....";
	}
}

开发者开发时，
知道子类都继承自一个抽象父类
因此，可以不去关心到底是哪个子类

因为---子类的规格必和抽象的父类一致

以后新增了泰国语，首页的开发者，根本无需改动
只需要增加一个泰国的welcome类 就只可以了.

所以有一些面向对象的介绍中，说面向对象的一个特点：可插拔特性


======回顾========

类常量
延迟绑定
抽象类

类常量/静态属性/方法 -->都是存放在类空间的
类常量用 const 来定义

延迟绑定：
是指类的self的定义不是以定义时为准，而是以运行时的计算结果为准


=====接口====
类：是某一类事物的抽象，是某类对象的蓝图
比如：女娲造人时，脑子中关于人的形象  就是人类 class Human

类如果是一种事物/动物的抽象
那么 接口，则是事物/动物的功能的抽象
即，再把他们的功能各拆成小块
自由组合成新的物种


例:

interface animal{
	public function eat();
}

interface monkey{
	public function run();
	public function cry();
}

interface wisdom{
	public function think();
}

interface bird{
	public function fly();
}

/*
如上，我们把每个类中的这种实现的功能拆出来

分析：如果有一种新生物，实现了eat()+run()+think(),这种智慧生物，可以叫做人。

*/

class Human implements animal,monkey,wisdom{
	public function eat(){
		echo '吃';
	}
	public function run(){
		echo "走";
	}
	public function cry(){
		echo "哭";
	}
	public function think(){
		echo "思考";
	}
}

$lisi = new Human();
$lisi->think();


接口语言与应用场景：
详见 class/1115_04.php 文件


=======自动加载=========

如上，没有require时，报错
手动require进来

如果网站比较大，model类比较多
HumanModel
UserModel
GoodsModel
CatModel
OrderModel
……
……
……

1:这么多的model，我用谁，就得include/require谁.

2:而且不知道，之前是否已经include/require进来某个类(这个用once可以解决，但once的效率很低)

这时 我们可以用自动加载

如果调用某个不存在的类
在报错之前
我们还有一次介入机会 __autoload函数

系统会调用 __autoload()函数
并把"类名"自动传给 __autoload函数

我们自然可以在 __autoload里加载需要的类

详见 1115_05.php  1115_06.php 文件

自动加载只能用 __autoload函数吗？
答：不是的，其实也可以指定一个函数

======异常处理=======

在对象里，自动连接数据库时，你怎么就知道已经连接成功了？

如果需要手动去打印出来，就太慢了

思考：我们以前用函数时，都是返回一个值，用值来判断各种情况
比如 返回true/false 代表成功/失败

现在我们用返回值 还行不行？

对象是一个已经生成了的复合体，等到生成后再检测就晚了一步
能否在对象生成的过程中就检测？

答：可以 用异常来处理

例：
error_reporting(0);
class mysql{
	protected $conn = NULL;

	public function __construct(){
		$this->conn = mysql_connect('localhost','root','1123456');
		if (!$this->conn) {
			// 发卫星报告

			// 在PHP中，卫星是规定好的一种对象
			// 哪个类的对象：Exception类的对象
			// new Exception ('错误原因',错误代码)---都是自定义的;
			$e = new Exception('漏油了',9);

			throw $e; // throw 抛出/扔出
		}
	}
}

try{ 					  // 测试，并试图捕捉错误信息
	$mysql = new mysql(); // 返回myql对象，并且自动连上了数据库
}catch(Exception $e){
	echo "捕捉到错误信息:<br />";
	echo $e->getMessage(),'<br />';
	echo "错误代码",$e->getCode(),'<br />';
	echo "错误文件",$e->getFile(),'<br />';
	echo "错误行",$e->getLine(),'<br />';
}


框架搭建：
路径信息的初始化
参数过滤 GET/POST
运行日志 运行中的错误信息，sql信息记录下来
报错级别 开发状态一个级别，上线状态一个级别
数据库类 
配置文件的读取

目前的知识
数据库类：Y
报错级别：Y
参数过滤：N(递归)
运行日志：要求把运行中的信息记录在文件上（文件操作，N）
	  日志按天形成目录存放/1119/log.txt,/1120/log.txt(目录创建，N)
读取配置文件：小项目，配置文件往往只放数据库信息，因此被数据库类读到，就行了
	      现在，配置文件的信息，还要包括缓存信息/smarty的目录信息，等等
	      就要求，要能被多个类读到
	      思考:总不能多个类，都include引入config.inc.php吧?



文件操作，自己下来看看，练练。详见kj\1119\01.php


==========回顾=========
文件处理函数
file_get_contents
file_put_contents

fopen
frea
fwrite
fclose

filemtime

fgets 获取一行

如何把csv文件导入到数据库

1:excel并不是开放的标准，是微软自己的，你只能猜测他的格式
标准还有可能变（目前国际上已经制定的标准文档规范）

操作excel,有开源的phpExcel开源的类

2：如果是简单的想导入数据库，可以先转换化csv文件
csv是一种简单的用逗号隔开的文件格式


把excel导入数据库的方法
excel->csv->文件处理

思路1：每次读一行
每一行的内容再逗号拆成数组

while (!feof($fh)) {
	$row = fgets($fh);
	print_r(explode('	', $row));
}


fgetcsv这个函数已经封装了csv文件相关规范
直接循环就行了
while (!feof($fh)) {
	$row = fgetcsv($fh);
	print_r($row);
}

批量处理文件内容
把小于10字节的文件，和含有fuck的文件删除掉


思路：
循环文件名
判断大小 filesize 如果<10,删

如果不小于，读内容，判断是否有f**k单词
如果有，用unlink来删除

关于文件缓存问题：
错误原因：
第一次filesize(curr.log)>1M
-->curr.log--rename-->12202345.bak
因为和上次一样，读的都是curr.log文件路径没变
所以缓存了filesize的结果，导致判断size始终是>1M的
循环5000次.....始终大于，始终备份

解决：清除fileze的缓存
clearstatcache(true,$log);


在函数中声明的static 静态变量
无论此函数调用多少次，只初始化一次

以后就会直接沿用该变量
这在递归时，很有用

static总结
1：修饰类的属性与方法为静态属性，静态方法
2：static::method(),延迟绑定
3：在函数/方法中，声明静态变量用

查找子孙树：
看kj/1123/02.php,03.php,04.php.05.php
















