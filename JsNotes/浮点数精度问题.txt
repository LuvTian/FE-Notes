console.log( 0.1+ 0.2);//0.30000000000000004

浮点数在进行加减乘除运算的时候都有可能会出现这种出现误差的问题
这是由于计算机在计算0.1+0.2的时候先把这两个十进制数转换成二进制数，而浮点数用二进制表达时是无穷的
EEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为：0.0100110011001100110011001100110011001100110011001100 
因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差。

#解决方案一：

对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数） 
如：(0.1*10 + 0.2*10) / 10 == 0.3 // true

这种方案要根据小数的位数进行选择
=====================================================================================================
在 Javascript 中，整数精度同样存在问题

console.log(19571992547450991); //=> 19571992547450990
console.log(19571992547450991===19571992547450992); //=> true
对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。

对于整数，我们可以通过用String类型的表示来取值或传值，否则会丧失精度。


对于js自身的numObj.toFixed(digits)方法也会有问题，比如：
1.335.toFixed(2) // 1.33

所以需要改写toFixed
// toFixed 修复
function toFixed(num, s) {
    var times = Math.pow(10, s)
    var des = num * times + 0.5
    des = parseInt(des, 10) / times
    return des + ''
}